# main.py (VERS√ÉO ASS√çNCRONA FINAL com Flask e Twilio)
import os
import json
import logging
import pytz
from datetime import datetime

from flask import Flask, request, jsonify
from google.cloud import tasks_v2
from twilio.rest import Client
import psycopg2

from notion_utils import create_notion_page
from db import salvar_conversa, buscar_nome_cliente

# --- Configura√ß√µes Iniciais ---
logger = logging.getLogger(__name__)

# 1. Inicializa a aplica√ß√£o Flask
app = Flask(__name__)

# 2. Configura√ß√µes do Google Cloud
PROJECT_ID = os.getenv("GCP_PROJECT_ID")
LOCATION_ID = os.getenv("GCP_LOCATION_ID")
QUEUE_ID = os.getenv("CLOUD_TASKS_QUEUE_ID")
SERVICE_ACCOUNT_EMAIL = os.getenv("GCP_SERVICE_ACCOUNT_EMAIL")
WORKER_URL = os.getenv("WORKER_URL") # URL do nosso pr√≥prio servi√ßo, configurada no Cloud Run

tasks_client = tasks_v2.CloudTasksClient()

# --- PORTA DE ENTRADA 1: Webhook para o Dialogflow ---
@app.route('/', methods=['POST'])
def vivi_webhook():
    """
    Fun√ß√£o "ATENDENTE": Chamada APENAS pelo Dialogflow.
    Responde r√°pido e delega o trabalho demorado.
    """
    request_json = request.get_json(silent=True)
    if not request_json:
        logger.error("Requisi√ß√£o sem corpo JSON ou malformado.")
        return jsonify({"error": "Invalid JSON"}), 400

    tag = request_json.get('fulfillmentInfo', {}).get('tag', '')
    parametros = request_json.get('sessionInfo', {}).get('parameters', {})
    
    numero_cliente_com_prefixo = request_json.get('sessionInfo', {}).get('session', '').split('/')[-1]
    numero_cliente = ''.join(filter(str.isdigit, numero_cliente_com_prefixo))
    if numero_cliente.startswith('55'):
        numero_cliente = f"+{numero_cliente}"
    
    # --- L√≥gica para salvar o nome (continua s√≠ncrona e r√°pida) ---
    if tag == 'salvar_nome_e_perguntar_produto':
        nome_cliente = parametros.get('person', {}).get('name', 'Cliente')
        salvar_conversa(numero_cliente, f"O cliente informou o nome: {nome_cliente}.", nome_cliente)
        print(f"‚úÖ Nome '{nome_cliente}' salvo para o n√∫mero {numero_cliente}.")
        return jsonify({})

    elif tag == 'definir_data':
        print("‚ÑπÔ∏è ATENDENTE: Recebida tag 'definir_data'. Processando corre√ß√£o de data...")
        
        # Pega o par√¢metro 'data_capturada' que vem da intent
        data_capturada = request_json.get('fulfillmentInfo', {}).get('parameters', {}).get('data_capturada', {})
        
        # Pega o par√¢metro de sess√£o que nos diz qual data corrigir (usando a vari√°vel correta 'parametros')
        campo_para_corrigir = parametros.get('campo_em_correcao', '')

        if data_capturada and 'year' in data_capturada and campo_para_corrigir in ['data_ida', 'data_volta']:
            # Prepara o objeto de data completo
            date_object = {
                "day": data_capturada.get("day"),
                "month": data_capturada.get("month"),
                "year": data_capturada.get("year")
            }
            # Atualiza o campo correto na sess√£o (usando a vari√°vel correta 'parametros')
            parametros[campo_para_corrigir] = date_object
            print(f"‚úÖ Webhook: Par√¢metro '{campo_para_corrigir}' atualizado para {date_object}")
        
        # Limpa as flags de corre√ß√£o (usando a vari√°vel correta 'parametros')
        parametros.pop('modo_correcao', None)
        parametros.pop('campo_em_correcao', None)
        
        # Monta a resposta para o Dialogflow, devolvendo os par√¢metros atualizados
        response = {
            "sessionInfo": {
                "parameters": parametros
            }
        }
        return jsonify(response)

    # --- L√≥gica para criar a tarefa ass√≠ncrona ---
    elif tag == 'salvar_dados_voo_no_notion' or tag == 'salvar_dados_cruzeiro_no_notion':
        print("‚ÑπÔ∏è ATENDENTE: Recebida tag 'salvar_dados_voo_no_notion'. Criando tarefa para notifica√ß√£o...")
        
        if not WORKER_URL:
            texto_resposta = "Ocorreu um erro de configura√ß√£o (WORKER_URL n√£o definida)."
        else:
            payload_para_tarefa = request.get_data()
            queue_path = tasks_client.queue_path(PROJECT_ID, LOCATION_ID, QUEUE_ID)

            task = {
                "http_request": {
                    "http_method": tasks_v2.HttpMethod.POST,
                    "url": WORKER_URL,
                    "headers": {"Content-type": "application/json"},
                    "body": payload_para_tarefa,
                    "oidc_token": {"service_account_email": SERVICE_ACCOUNT_EMAIL}
                }
            }
            try:
                tasks_client.create_task(parent=queue_path, task=task)
                print("‚úÖ ATENDENTE: Tarefa de notifica√ß√£o criada com sucesso na fila.")
                texto_resposta = "Sua solicita√ß√£o foi registrada com sucesso! Em instantes, um de nossos especialistas entrar√° em contato para te enviar a proposta. Obrigado! üòä"
            except Exception as e:
                logger.exception("‚ùå ATENDENTE: Falha ao criar tarefa no Cloud Tasks: %s", e)
                texto_resposta = "Tive um problema ao iniciar o registro da sua solicita√ß√£o. Nossa equipe j√° foi notificada."
        
        return jsonify({"fulfillment_response": {"messages": [{"text": {"text": [texto_resposta]}}]}})

    elif tag == 'atualizar_nome_cliente':
        print("‚ÑπÔ∏è ATENDENTE: Recebida tag 'atualizar_nome_cliente'.")
        nome_corrigido = parametros.get('person', {}).get('name')
        if nome_corrigido:
            # A fun√ß√£o salvar_conversa j√° atualiza o nome se o n√∫mero existir
            salvar_conversa(numero_cliente, f"O cliente corrigiu o nome para: {nome_corrigido}.", nome_corrigido)
            print(f"‚úÖ Nome corrigido para '{nome_corrigido}' no banco de dados.")
        # Retorna uma resposta vazia para que o Dialogflow use a fala definida na pr√≥pria rota.
        return jsonify({})


# --- PORTA DE ENTRADA 2: Rota para o Trabalhador do Cloud Tasks ---
@app.route('/processar-tarefa', methods=['POST'])
def processar_tarefa():
    """
    Fun√ß√£o "TRABALHADOR": agora salva no Notion E envia a notifica√ß√£o,
    sabendo diferenciar entre Passagens A√©reas e Cruzeiros.
    """
    print("üë∑ TRABALHADOR: Tarefa recebida. Iniciando processamento completo...")

    task_payload = request.get_json(silent=True)
    if not task_payload:
        print("üö® TRABALHADOR: Corpo da tarefa inv√°lido.")
        return "Corpo da tarefa inv√°lido.", 400

    parametros = task_payload.get('sessionInfo', {}).get('parameters', {})
    
    # Vari√°veis que ser√£o preenchidas por qualquer um dos fluxos
    dados_para_notion = {}
    tipo_viagem = "N√£o Identificado"
    resumo_viagem = "N√£o Identificado"
    
    numero_cliente_com_prefixo = task_payload.get('sessionInfo', {}).get('session', '').split('/')[-1]
    numero_cliente = ''.join(filter(str.isdigit, numero_cliente_com_prefixo))
    if numero_cliente.startswith('55'):
        numero_cliente = f"+{numero_cliente}"
    
    nome_cliente = buscar_nome_cliente(numero_cliente) or parametros.get('person', {}).get('name', 'N√£o informado')
    timestamp_contato = datetime.now(pytz.timezone("America/Recife")).isoformat()

    # --- L√ìGICA PARA DIFERENCIAR O TIPO DE VIAGEM ---
    # Se o par√¢metro 'destino_cruzeiro' existir, sabemos que √© um cruzeiro.
    if 'destino_cruzeiro' in parametros and parametros.get('destino_cruzeiro'):
        tipo_viagem = "Cruzeiro"
        porto_embarque = parametros.get('porto_embarque', {}).get('original', 'N√£o informado')
        resumo_viagem = f"Cruzeiro para {parametros.get('destino_cruzeiro', '')}, partindo de {porto_embarque}"
        
        dados_para_notion = {
            "data_contato": timestamp_contato,
            "nome_cliente": nome_cliente,
            "whatsapp_cliente": numero_cliente,
            "tipo_viagem": tipo_viagem,
            "origem_destino": resumo_viagem, # Usando um campo gen√©rico para o resumo
            "periodo_desejado": parametros.get('periodo_viagem', {}).get('original', 'N√£o informado'),
            "qtd_passageiros": f"Adultos: {parametros.get('adultos_cruzeiro', 0)}, Crian√ßas: {parametros.get('criancas_cruzeiro', 0)}",
            "preferencias": f"Companhia: {parametros.get('companhia_cruzeiro', 'Qualquer uma')}",
            "observacoes_adicionais": f"Acessibilidade: {parametros.get('acessibilidade_cruzeiro', False)}, Tarifa S√™nior: {parametros.get('tarifa_senior_cruzeiro', False)}"
        }
    else: # Sen√£o, √© o nosso fluxo antigo de passagem a√©rea
        tipo_viagem = "Passagem A√©rea"
        origem_nome = parametros.get('origem', {}).get('original', 'N√£o informado')
        destino_nome = parametros.get('destino', {}).get('original', 'N√£o informado')
        resumo_viagem = f"{origem_nome} ‚Üí {destino_nome}"

        data_ida_str, data_volta_str = None, None
        data_ida_obj = parametros.get('data_ida', {})
        if isinstance(data_ida_obj, dict) and all(k in data_ida_obj for k in ['year', 'month', 'day']):
            data_ida_str = f"{int(data_ida_obj.get('year'))}-{int(data_ida_obj.get('month')):02d}-{int(data_ida_obj.get('day')):02d}"

        data_volta_obj = parametros.get('data_volta')
        if isinstance(data_volta_obj, dict) and all(k in data_volta_obj for k in ['year', 'month', 'day']):
            data_volta_str = f"{int(data_volta_obj.get('year'))}-{int(data_volta_obj.get('month')):02d}-{int(data_volta_obj.get('day')):02d}"

        dados_para_notion = {
            "data_contato": timestamp_contato,
            "nome_cliente": nome_cliente,
            "whatsapp_cliente": numero_cliente,
            "tipo_viagem": tipo_viagem,
            "origem_destino": resumo_viagem,
            "data_ida": data_ida_str,
            "data_volta": data_volta_str,
            "qtd_passageiros": str(parametros.get('passageiros', '')),
            "perfil_viagem": parametros.get('perfil_viagem', ''),
            "preferencias": parametros.get('preferencias', '')
        }

    # --- 1. L√≥gica do NOTION (agora com dados gen√©ricos) ---
    try:
        print(f"üìÑ Enviando para o Notion: {dados_para_notion}")
        _, status_code = create_notion_page(dados_para_notion)

        if not (200 <= status_code < 300):
            print(f"‚ö†Ô∏è Falha ao criar p√°gina no Notion. Status: {status_code}. Continuando para o WhatsApp...")
        else:
            print("‚úÖ P√°gina criada no Notion com sucesso.")

    except Exception as e:
        logger.exception("üö® TRABALHADOR: Falha CR√çTICA na etapa do Notion: %s", e)

    # --- 2. L√≥gica do WHATSAPP (agora com dados gen√©ricos) ---
    try:
        # ... (seu c√≥digo do WhatsApp continua aqui, mas usando as vari√°veis gen√©ricas)
        print("üì± Etapa 2: Preparando notifica√ß√£o do WhatsApp...")
        # ... (c√≥digo de autentica√ß√£o do Twilio) ...
        twilio_client = Client(os.getenv("TWILIO_ACCOUNT_SID"), os.getenv("TWILIO_AUTH_TOKEN"))

        content_variables = json.dumps({
            '1': nome_cliente,
            '2': tipo_viagem,
            '3': resumo_viagem
        })
        
        # ... (c√≥digo de envio da mensagem do Twilio) ...
        message = twilio_client.messages.create(...)

        print(f"‚úÖ Notifica√ß√£o por WhatsApp enviada com sucesso! SID: {message.sid}")

    except Exception as e:
        logger.exception("üö® TRABALHADOR: Falha CR√çTICA na etapa do WhatsApp: %s", e)
        return "Erro no processo do trabalhador", 500

    return "OK", 200

# --- NOVA PORTA DE ENTRADA 3: Webhook para L√≥gica de Dados ---
# Em main.py, substitua a fun√ß√£o inteira por esta:

@app.route('/gerenciar-dados', methods=['POST'])
def gerenciar_dados():
    """
    Webhook para manipular a atribui√ß√£o de par√¢metros de data.
    """
    try:
        request_json = request.get_json(silent=True)
        tag = request_json.get("fulfillmentInfo", {}).get("tag", "")
        parametros_sessao = request_json.get("sessionInfo", {}).get("parameters", {})

        print(f"‚ÑπÔ∏è Webhook /gerenciar-dados recebido com a tag: {tag}")

        if tag in ["definir_data_ida", "definir_data_volta"]:
            data_capturada = request_json.get("fulfillmentInfo", {}).get("parameters", {}).get("data_capturada", {})
            if data_capturada and 'year' in data_capturada:
                objeto_data = {"day": data_capturada.get("day"), "month": data_capturada.get("month"), "year": data_capturada.get("year")}
                
                if tag == "definir_data_ida":
                    parametros_sessao["data_ida"] = objeto_data
                elif tag == "definir_data_volta":
                    parametros_sessao["data_volta"] = objeto_data
        
        # A resposta agora apenas devolve os par√¢metros atualizados, sem for√ßar navega√ß√£o.
        resposta = {"sessionInfo": {"parameters": parametros_sessao}}
        return jsonify(resposta)

    except Exception as e:
        logging.error(f"‚ùå Erro no webhook /gerenciar-dados: {e}")
        return jsonify({})